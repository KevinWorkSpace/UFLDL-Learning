# 优化方法：随机梯度下降（Optimization: Stochastic Gradient Descent）  
## 概览（Overview）  
批处理的方法，如有限内存 $BFGS$ ，使用完整的训练集来计算下一次的参数更新，在每次迭代时往往可以很好地收敛到局部最优解。也有一些现成的实现（例如 $MATLAB$ 中的 $minfunc$ 函数），因为有很少的超参数需要调整，所以可以直接拿来用。然而一般来说，在实践中计算整个训练集的损失（译者注：或称为代价）和梯度的过程是非常缓慢的，有时因为数据集太大，无法完全装进主内存，在一台机器上计算更是不可能完成。

批处理优化方法的另一个问题是，没有给一个简单的方法，可以将新的数据进行“在线实时”处理。随机梯度下降（ $SGD$ ）解决了这两个问题，在跑了单个或者少量的训练样本后，便可沿着目标函数的负梯度（译者注：更新，来寻找局部最优）。 $SGD$ 在神经网络中的使用是出于运行反向传播会在整个训练集上进行的高（译者注：计算）成本。 $SGD$ 可以克服这一（译者注：高计算）成本（问题），并加快收敛速度。  

## 随机梯度下降（Stochastic Gradient Descent）  
标准的梯度下降算法更新目标函数 $J(\theta)$ 中的参数 $\theta$ （译者注：的过程），如下，  

$$ \theta = \theta - \alpha \nabla_\theta E[J(\theta)] $$  

其中，因为是对整个训练集上的代价和梯度的近似，所以上述方程中的期望值 $E[J(\theta)]$ 是近似（等于整个训练集）的。随机梯度下降（ $SGD$ ）在更新和计算参数梯度时，由于是使用单个或者少量的训练样本，只是稍稍偏离了期望值。新的更新公式定义如下，  

$$ \theta = \theta - \alpha \nabla_\theta J(\theta; x^{(i)},y^{(i)}) $$  

其中，$ (x^{(i)},y^{(i)}) $ 是训练集中的一个带标记的样本。  

通常来说， $SGD$ 中每个参数更新的计算并非使用单个样本，而是关于少量训练样本或者一小批样本。这样做的原因有两个：第一，这降低了参数更新过程中的方差，使收敛的过程更稳定，第二，这允许在计算中借助深度优化的矩阵运算，可以很好地将成本和梯度的计算矢量化。尽管 $minibatch$ 的最佳值会因不同的应用和架构变化，但一个有代表性的 $minibatch$ 大小是 $256$ 。  

在 $SGD$ 中的学习率 $\alpha$ 值会比（全量）梯度下降（译者注：这里的全量梯度下降，即 $batch\ gradient\ descent$，每次迭代过程中对参数的更新是基于整个训练集）中的学习率小很多，因为前者在更新过程中的方差更大（译者注：因为并非是在整个训练集上计算参数更新值，少量的训练样本带来的参数更新并不稳定）。选择合适的学习率和学习率变更策略（即改变学习率的学习速度）是相当困难的。一个标准且在实际中有效的方法，是在迭代开始时就使用一个足够小的固定学习率，这样固定且小的学习率在首次迭代（迭代，即在训练集上的一次完整遍历）提供了稳定的收敛性，或两次迭代后随着收敛慢下来，将学习速率降低为原来的一半。  

一个更好的方法是在每次迭代后使用一组固定的学习率，并且当紧邻的两次迭代，目标函数变化值小于某个较小的阈值时，就降低学习率。这往往会很好地收敛于一个局部最优。另一个常用的学习率变化策略，学习率 $\frac{a}{b+t}$ 随着迭代次数 $t$ 变化而变化，其中变量 $a$ 和 $b$ 决定了初始时的学习率，并且学习率的开始减少的过程是独立的。还有更先进的方法，包括基于回溯线搜索的最佳更新寻找（策略）。  

最后但重要的一点是，在 $SGD$ 中，我们提供给算法的数据（样本的）顺序。如果给（算法）数据是某种有意义的顺序，这可能会使得梯度偏离并导致收敛性差。一般（为避免该问题）我们都会在训练过程中的每次迭代前，对数据的次序进行“洗牌”（译者注：重新排序）。  

## 动量（Momentum）  
如果目标函数（译者注：可视化）为一个沿着最优方向的长长浅沟，在很多地方有陡峭的墙坡的形式，由于负梯度会沿着一条（当前最）陡峭而不是沿着（全局）最低山沟的方向，标准的 $SGD$ 将趋于在（局部）窄的峡谷里并来回振荡。深层（网络）结构的目标函数就会有着局部最优，并在这种形式下，标准的 $SGD$ 会导致收敛地很慢，特别是在第一次的陡坡的拉升过程中。动量是一个（推动当前参数）朝目标方向沿着目标浅沟更快（进行参数更新）的一种方法。下面给出动量的更新过程，  

$$
\begin{align}
v &= \gamma v+ \alpha \nabla_{\theta} J(\theta; x^{(i)},y^{(i)}) \\
\theta &= \theta - v
\end{align}
$$

上述方程中， $V$ 是当前的速度矢量，它和参数向量 $\theta$ 有相同的维度。学习率 $\alpha$ 如上所述，在使用动量的时候，因为梯度会较大，所以动量所需要的值就会比较小，。最后， $\gamma \in (0,1]$ 确定已经完成的迭代次数，这些迭代次数中梯度纳入当前更新的程度。一般 $\gamma$ 的值设为 $0.5$，直到初始学习稳定，之后被增加到 $0.9$ 或更高。